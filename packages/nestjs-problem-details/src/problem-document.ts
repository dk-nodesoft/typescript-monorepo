import { BaseException } from '@dk-nodesoft/base-exceptions';
import tsUtils from '@dk-nodesoft/ts-utils';
import { HttpException, HttpStatus, Logger } from '@nestjs/common';
import { defaultHttpErrors } from './constants';
import type { ErrorDetail, ProblemDetail, ProblemDetailExtras, ProblemDetailInternal } from './types';

const Terms = {
  unspecified_error: 'An error occurred'
};

/**
 * property type (required)
 * A URI reference [RFC3986] that identifies the problem type.
 * This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type
 * (e.g., using HTML [W3C.REC-html5-20141028]).
 * When this member is not present, its value is assumed to be "about:blank".
 *
 * property title (required):
 * A short, human-readable summary of the problem type.
 * It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization
 * (e.g., using proactive content negotiation; see[RFC7231], Section 3.4).
 *
 * property status (required):
 * The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
 *
 * property detail (options):
 * A human-readable explanation specific to this occurrence of the problem.
 *
 * property instance (options):
 * A URI reference that identifies the specific occurrence of the problem.
 * It may or may not yield further information if dereferenced.
 *
 * property internal (optional):
 * An optional custom object holding any internal ifnormation which will only be returned in development and test environment
 *
 */

export class ProblemDocument {
  private readonly logger = new Logger(ProblemDocument.name);

  protected constructor(private readonly problemDetail: ProblemDetail) {}

  /**
   * create an instance of ProblemDocument providing a problem detail object
   */
  static create(problemDetail: ProblemDetail): ProblemDocument {
    return new ProblemDocument({ ...problemDetail });
  }

  /**
   * create an instance of ProblemDocument from a number of other exception types
   * @throws TypeError
   */
  static from(exception: string): ProblemDocument;
  static from(exception: BaseException): ProblemDocument;
  static from(exception: HttpException): ProblemDocument;
  static from(exception: Error): ProblemDocument;
  static from(exception: ProblemDetail): ProblemDocument;
  static from(exception: ProblemDetail | Error | HttpException | BaseException | string): ProblemDocument {
    if (exception instanceof HttpException) {
      return ProblemDocument.fromHttpException(exception);
    }
    if (exception instanceof BaseException) {
      return ProblemDocument.fromBaseException(exception);
    }

    if (exception instanceof Error) {
      return ProblemDocument.fromError(exception);
    }

    if (typeof exception === 'string') {
      return ProblemDocument.fromError(new Error(exception));
    }

    if (exception.type && exception.title && exception.status) {
      return new ProblemDocument({ ...exception });
    }

    throw new TypeError('Failed to create a ProblemDocument from provided paramters');
  }

  /**
   * create an instance of ProblemDocument from an Error
   */
  static fromError(exception: Error): ProblemDocument {
    const status = HttpStatus.INTERNAL_SERVER_ERROR;
    const type = defaultHttpErrors[status];
    const title = tsUtils.startCase(type);
    const detail = exception.message;
    const internal: ProblemDetailInternal = { stack: exception.stack };

    return new ProblemDocument({ type, status, title, detail, internal });
  }

  /**
   * create an instance of ProblemDocument from a nest HttpException
   */
  static fromHttpException(exception: HttpException): ProblemDocument {
    const status = exception.getStatus();

    const errorResponse = exception.getResponse();

    // If errorResponse is an instance of ProblemDocument clone it and add stack information
    if (errorResponse instanceof ProblemDocument) {
      const internal: ProblemDetailInternal = { stack: exception.stack };
      return errorResponse.duplicate({ internal });
    }

    // If errorResposnse is a string we simply return a basic ProblemDocument
    if (typeof errorResponse === 'string') {
      const type = defaultHttpErrors[status];
      const title = tsUtils.startCase(type);
      const detail = errorResponse;
      return new ProblemDocument({ type, status, title, detail });
    }

    const response: {
      statusCode?: number;
      error?: unknown;
      message?: unknown;
      internal?: object;
    } = { ...errorResponse };

    delete response.statusCode;

    const type = defaultHttpErrors[status];
    let title = tsUtils.startCase(type);
    let detail: string | undefined;

    if (tsUtils.isString(response.message) && tsUtils.isString(response.error)) {
      title = response.error;
      detail = response.message;

      delete response.error;
      delete response.message;
    } else if (tsUtils.isString(response.message) && tsUtils.isEmpty(response.error)) {
      title = response.message;
      detail = Terms.unspecified_error;

      delete response.message;
    } else if (tsUtils.isString(response.message)) {
      detail = response.message;
      delete response.message;
    }

    const internal: ProblemDetailInternal = {
      ...response.internal,
      stack: exception.stack
    };

    return new ProblemDocument({ type, status, title, detail, internal });
  }

  /**
   * create an instance of ProblemDocument from a nest HttpException
   */
  static fromBaseException(exception: BaseException): ProblemDocument {
    const status = exception.getStatus();
    const type = exception.getCode();
    const detail = exception.message;
    const title = exception.getTitle();
    const messageParameters = exception.getMessageParameters();
    const details = exception.getDetails();

    const internal: ProblemDetailInternal = {
      stack: exception.stack,
      ...details
    };

    const extras: ProblemDetailExtras = {
      ...messageParameters
    };

    return new ProblemDocument({ type, status, title, detail, extras, internal });
  }

  /**
   * Provide the representation og the ProblemDocument as Problem Details response
   */
  createResponse(): ProblemDetail {
    const type = this.problemDetail.type || defaultHttpErrors[this.problemDetail.status];
    const title = this.problemDetail.title || tsUtils.startCase(type);

    return { ...this.problemDetail, type, title };
  }

  /**
   * A helper function for creating a duplicate with an option for adding/overwriting extensiosn properties
   */
  duplicate(problemDetail?: Partial<ProblemDetail>): ProblemDocument {
    return new ProblemDocument({ ...this.problemDetail, ...problemDetail });
  }

  /**
   * create an error log entry from this ProblemDocument
   */
  logError(): this {
    const response = this.createResponse();
    const msg = `${response.detail} (${response.title})`;
    this.logger.error({ msg, response });
    return this;
  }

  /**
   * get the nested errors object of the problemDetail object
   */
  getError(): ErrorDetail[] | undefined {
    return this.problemDetail.errors;
  }

  /**
   * get the newsted internal object of the problemDetail object
   */
  getInternal(): ProblemDetailInternal | undefined {
    return this.problemDetail.internal;
  }
}
